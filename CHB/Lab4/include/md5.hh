/*
 Copyright (c) 2021 Haobin Chen

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
#pragma once

#include <cstddef>
#include <cstdint>
#include <string>

#ifndef MD5
// Basic logic functions used at each round.
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

#define ROT_LEFT(num, n) \
  { (((num) << (n)) | ((num) >> (32 - (n)))) }

// Bootstrapped functions.
#define FF(a, b, c, d, x, s, ac)        \
  {                                     \
    (a) += F((b), (c), (d)) + (x) + ac; \
    (a) = ROT_LEFT((a), (s));           \
    (a) += (b);                         \
  }
#define GG(a, b, c, d, x, s, ac)        \
  {                                     \
    (a) += G((b), (c), (d)) + (x) + ac; \
    (a) = ROT_LEFT((a), (s));           \
    (a) += (b);                         \
  }
#define HH(a, b, c, d, x, s, ac)        \
  {                                     \
    (a) += H((b), (c), (d)) + (x) + ac; \
    (a) = ROT_LEFT((a), (s));           \
    (a) += (b);                         \
  }
#define II(a, b, c, d, x, s, ac)        \
  {                                     \
    (a) += I((b), (c), (d)) + (x) + ac; \
    (a) = ROT_LEFT((a), (s));           \
    (a) += (b);                         \
  }
#endif

static const uint16_t MD5_BLOCK_LEN = 64u;

static const uint16_t MD5_MESSAGE_LEN_REMAINDER = 56u;

static const uint16_t MD5_HEADER = 8u;

static const uint8_t mask = ((1u << 8) - 1);

/**
 * @brief Initial buffer in LITTLE-ENDIAN mode.
 * This can also be regarded as four 32-bit registers.
 *
 */
static const uint32_t initial_buffer[4] = {
    0x67452301,
    0xefcdab89,
    0x98badcfe,
    0x10325476,
};


static const uint32_t shift_table[4][4] = {
    7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21,
};

/**
 * @brief Pad the message to a specific length: m = 512 * n + 448, where n is an
 *        arbitrary number.
 * @note  Even if the message m's length does hold for the above equation, we
 *        still need to pad it with 1000000...
 *
 * @param input
 * @param output            The padded message will be output to this variable.
 * @param message_len
 */
void pad_message(uint8_t* input, uint8_t* output, size_t* meesage_len);

/**
 * @brief Convert an unsigned long logn type to 64-bit string.
 *
 * @param input
 * @param output
 * @param message_len
 */
void to_64_bits(const uint64_t& input, uint8_t* output);

/**
 * @brief Compress the information
 *
 * @param input
 * @param output
 * @param message_len
 */
void message_digest(unsigned char* input, unsigned char* output,
                    size_t* message_len);

/**
 * @brief Process one block of the raw message.
 * 
 * @param input 
 * @param state     The input of the CV_{q} generated by the last round.
 */
void digest_one_block(unsigned char* input, uint32_t* state);

/**
 * @brief Do MD5.
 * 
 * @param message 
 * @return std::string 
 */
std::string md5_hash(const std::string& message);

std::string to_string(unsigned char* in, size_t* message_len);

